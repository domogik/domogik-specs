Purpose
========
A first try to implement the lighting schema in domogik. For now, this plugin is only for plugins developpers.
You must update your plugin to allow scene managment.

Installation
=============
Install the plugin with the package manager in Domogik.
Today, there is no interface for adding scenes, you must create a text file.
Put it into /src/share/domogik/data/lighting/ in develop mode or /var/lib/domogik/domogik_packages/data/lighting in install mode.
The file must have the same name as the scene, followed by the extension ".scn"
Here is an example :

.. code-block::
    
    samtv.scn :
    
    [Scene]
    name=samtv
    location=Salle Ã  manger
    devices=TS24,TS17,TS35,ARRGB1
    
    [TS24]
    -1=0,0
    
    [TS17]
    -1=20,30
    
    [TS35]
    -1=30,30
    
    [ARRGB1]
    1=11,0
    2=22,0
    3=33,0
    

First section [Scene]
Some description about the scene and the important device list.
Under it, you find on sectione per devices, in each one, the configuration of each channel in the device.
By convention, channel -1 is the default channel, 0 represents all the channels and another value a specific channel.
The value of the channel represents the level, followed by the faderate.

After creating the scene file, you can start the plugin.

You can now add a device in domogik, using the Scene devicetype. Use the scene name as address.

Update the plugin code 
========================
Use the correct lightplugin library :
.. code-block::
    from domogik_packages.xpl.lib.lightplugin import LightingExtension
    

Add 3 callbacks fuction to your plugin :
.. code-block::
        def lighting_activate_device(self, device, channel, level, faderate):
            '''
            Activate a device during a scene process.
            @param device : address of the device (ie TS14)
            @param channel : Not used in this case
            @param level : level of light. 0 to say OFF and 100 to say ON
            @param faderate : the duration of the scene
            '''
            level = int(level)
            faderate = int(faderate)
            if level == 0 :
                self.send_off(device)
            elif level == 100 :
                self.send_on(device)
            else :
                if faderate == 0:
                    self.send_dim(device, level)
                else :
                    self.send_change(device, level, faderate)
    
        def lighting_deactivate_device(self, device, channel, level, faderate):
            '''
            Deactivate a device during a scene process.
            @param device : address of the device (ie TS14)
            @param channel : Not used in this case
            @param level : level of light. 0 to say OFF and 100 to say ON
            @param faderate : the duration of the scene
            '''
            self.send_off(device)
    
        def lighting_valid_device(self, device, channel):
            '''
            Check that device is managed by this plugin. Called when the scene
            configuration is loaded.
            The first way to do ti is to check the device syntax.
            We only accept device like TSX, where X is an integer.
            In this case, we do not check that this device exists on telldusd.
            The second way to do it, is to try to get configuration from telldusd.
            @param deviceid : id of the device (ie 14)
            @return : address of the device (ie TS14)
            '''
            return self._telldusd.check_device(device)
    
The 2 first functions are used when a scene is activated or desactivated : they must activate (or deactivate) the (device,channel) passed in parameter. The last one is used to validate that the (device,channel) is managed by this plugin.

Finally, add the following lines to your plugin initialisation :
.. code-block::
    self._lighting = LightingExtension(self)
    self._lighting.enable_lighting(self._mytelldus.lighting_activate_device,
           self._mytelldus.lighting_deactivate_device, self._mytelldus.lighting_valid_device)
    

How it works
=============
The lightplugin library asks informations to the lighting server. This one send a list of all the scenes it managed.
Then the lighting extension ask for configuration of every scenes. The server sends each scene, with the device configuration. Using this information, the plugin build a list of devices to activated for every scene.
Now, the plugin will manage scene activation (and deactivation) directly.

 Xpl schema
============
You can also use xpl to manage scene/device under the lighting device :
Getting the scene list
***********************
.. code-block::
    xpl-cmnd
    lighting.config
    {
    command=scnlist
    [client=fooplugin]
    }
The server will respond :
.. code-block::
    xpl-stat
    lighting.config
    {
    command=scnlist
    status=ok
    scene-count=2
    scenes=foo,samtv
    }

 Get informations about a scene
********************************
.. code-block::
    xpl-cmnd
    lighting.config
    {
    command=scninfo
    scene=foo
    [client=fooplugin]
    }
The server will respond :
.. code-block::
    xpl-stat
    lighting.config
    {
    command=scninfo
    [client=fooplugin]
    status=ok
    scene=foo
    name=foo
    room=None
    floor=None
    comment=None
    device-count=5
    device=TS34,-1,0,0
    device=ARGD,1,1,1
    device=ARGD,2,2,2
    device=ARGD,3,3,3
    device=TS17,-1,50,30
    }

Adding a scene
***************
.. code-block::
    xpl-cmnd
    lighting.config
    {
    command=scnadd
    scene=foo
    name=test scene
    }

Deleting a scene
*****************
.. code-block::
    xpl-cmnd
    lighting.config
    {
    command=scndel
    scene=foo
    }

Adding a device to a scene
***************************
.. code-block::
    xpl-cmnd
    lighting.config
    {
    command=scnadddev
    scene=foo
    device=TS17
    channel=-1,50,30
    }
or adding a multichannel device to a scene
.. code-block::
    xpl-cmnd
    lighting.config
    {
    command=scnadddev
    scene=foo
    device=ARGD
    channel=1,1,1
    channel=2,2,2
    channel=3,3,3
    }
    

Deleting a device from a scene
*******************************
Deleting specifics channels :
.. code-block::
    xpl-cmnd
    lighting.config
    {
    command=scndeldev
    scene=foo
    device=ARG2
    channel=2
    }
    
or deleting of all channels
.. code-block::
    xpl-cmnd
    lighting.config
    {
    command=scndeldev
    scene=foo
    device=TS17
    channel=0
    }
    

Trigs updates
**************
Whe a scene is modified on the server, it will send a message
.. code-block::
    xpl-trig
    lighting.config
    {
    command=scninfo
    status=ok
    scene=foo
    name=foo
    room=None
    floor=None
    comment=None
    device-count=5
    device=TS34,-1,0,0
    device=ARGD,1,1,1
    device=ARGD,2,2,2
    device=ARGD,3,3,3
    device=TS17,-1,50,30
    }
If the scene is deleted, the device list will be empty.

Using it with an arduino
=========================
The next step is to build an arduino library.

Old documentation
==================
Implementation of the LIGHTING schema in Domogik.
This plugin is in early stage, so it is not publish into the sources. Actually, configuration is store directly in code, so it should be a bad idea to share it.
For now, this page is only a memento.
The full schema is available `here <http://xplproject.org.uk/wiki/index.php?title=Schema\_-\_LIGHTING>`_
If you want to participate, please do it.

Developpers notes
******************
Notes about the lighting schema notion :
*****************************************
`Gateway <http://xplproject.org.uk/wiki/index.php?title=Schema\_-\_LIGHTING#xPL\_gateway>`_ : implemented
`Networks <http://xplproject.org.uk/wiki/index.php?title=Schema\_-\_LIGHTING#Network>`_ : not implemented. Nobody use it for now, so we always work in the preferred network.  We silently ignore this option as mention in documentation.
`Devices <http://xplproject.org.uk/wiki/index.php?title=Schema\_-\_LIGHTING#Device>`_ : implemented.
`Channels <http://xplproject.org.uk/wiki/index.php?title=Schema\_-\_LIGHTING#Channels>`_ : implementation in progress. For now, one channel by device is developed but multichannels devices will be soon.
`Faderate <http://xplproject.org.uk/wiki/index.php?title=Schema\_-\_LIGHTING#Fade\_Rate>`_ : not implemented. Don't know if it will be. Options are present in messages but silently ignored.
`Scenes <http://xplproject.org.uk/wiki/index.php?title=Schema\_-\_LIGHTING#Scene>`_ : Implemented.
Activating and deactivating scenes is implemented. Goto not (dont need it)

!!!! Problems
When activating a scene, I send a message to every device using the xpl network. It tooks approximatively 1 second to activate a device. In a scene with 10 devices, it take more than 10 seconds to activate it.
Need to fid a workaround to this.

Externals
**********
One interesting thing in implementing this schema is that it can manage external stuff (like arduinos).

!!!! First case of use : ARLIGHT
ARLIGHT is an evolution of ar_rgb.

!!!!! Device's names
I need to add a move detector, a sound ans a vibration sensor to it. 
My house need to know if I am here, so I need many move detectors. Arduino is a good place to add one :)
So the arduino will create 2 or more devices
how should we name them ?
 : one for the rgb in the lighting schema and another using the sensor basic.
Configuration of the movement detector is trvial, so we don't care about it for now. We only study the case of the RGB


What can domogik do ?
!!!!! Configuration
For now, all the configuration (ip,source,device name, ...) is store in the code.
If we want to update them, we need to create a small web server on the arduino, use the serial console, or we can try to use them in domogik : 

When the arduino starts, it asks informations about its RGB device, including all parameters it wants.
Ligthing catch the message. If a configuration is available, it send it to the arduino. If none, it creates the required fileds in lightings devices. User update the configuration and save it.
The arduino will loop until it can get a configuration.
When it get one, it starts (entering in a "normal" loop)

.. code-block::
    
    xpl-cmnd
    {
    hop=1
    source=domogik-send.satellitep100
    target=*
    }
    lighting.request
    {
    request=devconf
    device=ARRGB1
    }
    

.. code-block::
    
    xpl-stat
    {
    hop=1
    source=domogik-lighting.satellitep100
    target=*
    }
    lighting.devconf
    {
    status=ok
    device=ARRGB1
    name=Ar_Light RGB
    report-on-manual=false
    room=Salle Ã  manger
    scene-count=9
    scene=samtv,1,11,0
    scene=samtv,2,22,0
    scene=samtv,3,33,0
    scene=samamb,1,AA,0
    scene=samamb,2,BB,0
    scene=samamb,3,CC,0
    scene=samall,1,DD,0
    scene=samall,2,EE,0
    scene=samall,3,FF,0
    }
    

This process is based on the device name. We will use the serial to initialize it. We can also use the DHCP hostname. I will try it later as the EthernetUdp and DHCP/DNS is broken in Arduino 1.0.

Now we must tell the LIGHTING that ARLIGHT can respond to scene messages (and the device one too(maybe a bad idea)).
2 ways to do this : 
ARLIGHT say to LIGHTING the messages it can manage or LIGHTING ask ARLIGHT before sending message.
I prefer the first one.
When ARLIGHT starts, it register its channels and actions (on,off, dim, activate and deactivate) in LIGHTING.
If configuration has been updated, it reload it ?
For now, we don't implement this. But we should remenber it.

!!!!! Actions
A device can know the scenes in which it is an actor. So maybe it can catch directly scene message, not the devices ones.
My arduino is a AtMega 2560. It has 8KB of SRAM and 4KB of eeprom. 
We will use the eeprom to store configuration of the device : name,heartbeat,room,floor or scenes. 
What do we need : 
* functions to read and write the differents parameters.
* functions to find and append scenes
* fucntions to format and check the pseudo file on eeprom
EEPROM has a limited number of writes (from thousand to thousand of thousand). Don't known what about the arduino one. And you ?

Scene/Device message.
We want that ARLIGHT manage directly scene messages : so when lighting receive a message, it doesn't send to the ARLIGHT.


!!!!! RGB/Channels.
Actually the plugin send the color using the standard RGB format.
`Channels in lighting <http://xplproject.org.uk/wiki/index.php?title=Schema\_-\_LIGHTING#Channels>`_ are used to manage differents lights on the same device. 
We will use the level parameter to store the R ( or G or B ) composante of the color.
Channels :
1 : R
2 : G
3 : B
0 : All channels

In ligthing, we could use the channels to send the color.
We must include all the 3 channels in one XPL message. Otherwise, it can take up to 3 seconds to switch to the new color.

.. code-block::
    {
    hop=1
    source=domogik-lighting.satellitep100
    target=*
    }
    lighting.devinfo
    {
    status=not-found
    device=ARRGB1
    name=Ar_Light RGB
    report-on-manual=false
    room=Salle Ã  manger
    channel-count=3
    primary-channel=1
    channel=1,true,FF,0
    channel=2,true,FF,0
    channel=3,true,FF,0
    scene-count=0
    }
